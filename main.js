(()=>{"use strict";class e{constructor(e,t){this.device=e}run(e,t){}getBindGroupLayout(){return this.bindGroupLayout}}const t="struct ObjectData {\n    model: array<mat4x4<f32>>,\n}\n\n// Number of bytes: 32\nstruct BoidData {\n    targetPosition: vec4<f32>, // 16 bytes\n    avoidanceVector: vec4<f32>, // 16 bytes\n    hasTarget: u32,            // 4 bytes\n    speed: f32,               // 4 bytes\n}\n\n\n@binding(0) @group(0) var<storage, read_write> objects: ObjectData;\n@binding(1) @group(0) var<storage, read_write> boids: array<BoidData>;\n@binding(2) @group(0) var<uniform> time: f32;\n@binding(3) @group(0) var<uniform> dT: f32;\n\n@compute @workgroup_size(64)\nfn avoidanceMain(@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let index = global_id.x;\n    if (index < arrayLength(&objects.model) ) {\n\n        var avoidance = vec3(0.0, 0.0, 0.0);\n\n        var avoidanceDistance = 0.3;\n\n        for (var i = 0u; i < arrayLength(&objects.model); i = i + 1u) {\n            if (i != index) {\n                // if the distance between the two objects is less than 0.1\n                // move the object away from each other\n                let distance = distance(get_position(objects.model[index]), get_position(objects.model[i]));\n                if (distance < avoidanceDistance) {\n                    // objects.model[index] = move_towards(objects.model[index], get_position(objects.model[index]) - get_position(objects.model[i]), 0.01);\n                    \n                    var avVector = (get_position(objects.model[index]) - get_position(objects.model[i]));\n                    avVector = safe_normalize(avVector);\n\n                    // scale exponentially by distance 0.13 max\n                    avVector = avVector * max(0.0, (avoidanceDistance - distance));\n\n                    avoidance = avoidance + avVector;\n                }\n            }\n        }\n\n        var maxAvoidanceMagnitude = 1.0;\n        \n        avoidance.z = 0.0;\n        // avoidance = normalize(avoidance) * min(length(avoidance), maxAvoidanceMagnitude);\n        \n        avoidance *= 1.0;\n        \n\n        boids[index].avoidanceVector = vec4<f32>(avoidance, 0.0);\n\n        var defaultSpeed = 0.01;\n\n        // let distance = distance(get_position(objects.model[index]), boids[index].targetPosition.xyz);\n        // objects.model[index] = move_towards(objects.model[index], boids[index].targetPosition.xyz + avoidance, defaultSpeed);\n    }\n\n    return;\n}\n\n\n\n@compute @workgroup_size(64)\nfn movementMain (@builtin(global_invocation_id) global_id: vec3<u32>) {\n    let index = global_id.x;\n    if (index < arrayLength(&objects.model) ) {\n        \n\n        var avoidance = boids[index].avoidanceVector.xyz;\n        avoidance.z = 0.0;\n\n        var defaultSpeed = 0.01 * boids[index].speed;\n\n        // var movementDirection = (boids[index].targetPosition.xyz - get_position(objects.model[index])) + avoidance;\n        var targetWeight = 0.1;\n        let avoidanceWeight = 0.4;\n\n        var targetP = boids[index].targetPosition.xyz;\n        var movDir = (targetP - get_position(objects.model[index]));\n\n        // check distance to target \n        if (distance(get_position(objects.model[index]), targetP) < 0.5) {\n            movDir = vec3(0.0, 0.0, 0.0);\n        }\n\n\n        if (boids[index].hasTarget == 0u) {\n            targetWeight = 0.0;\n        }\n\n        var movementDirection = safe_normalize(movDir * targetWeight + avoidance * avoidanceWeight);\n\n        // clamp length without normalizing\n        if (length(movementDirection) > 1.0) {\n            movementDirection = safe_normalize(movementDirection);\n        }\n\n\n        var destination = get_position(objects.model[index]) + movementDirection;\n        \n        var lastPosition = get_position(objects.model[index]);\n        \n        objects.model[index] = move_towards(objects.model[index], destination, defaultSpeed);\n\n\n\n        var newPosition = get_position(objects.model[index]);\n\n        var velocity = newPosition - lastPosition;\n\n        var speed = length(velocity) / dT;\n\n        var avoidanceLength = length(avoidance) / 0.5;\n\n\n\n        // scale x by avoidance length, so it looks like boid is getting squished\n\n        var s = 0.3 - avoidanceLength;\n        s = max(0.23, s);\n        s = min(0.3, s);\n\n        var target_scale = vec3<f32>(s, 0.3, 0.3);\n        var current_scale = get_scale(objects.model[index]);\n\n        // lerp\n        var scale = mix(current_scale, target_scale, 15.0 * dT);\n\n        objects.model[index] = set_scale(objects.model[index], scale);\n\n    \n    }\n\n    return;\n}",n="\nfn translate(matrix: mat4x4<f32>, translation: vec3<f32>) -> mat4x4<f32> {\n    // Add the translation vector to the last column of the matrix\n    return mat4x4<f32>(\n        matrix[0], // Keep the original X-axis\n        matrix[1], // Keep the original Y-axis\n        matrix[2], // Keep the original Z-axis\n        vec4<f32>(\n            matrix[3].x + translation.x, // Update translation component\n            matrix[3].y + translation.y,\n            matrix[3].z + translation.z,\n            matrix[3].w              // Keep the homogeneous coordinate\n        )\n    );\n}\nfn safe_normalize(v: vec3<f32>) -> vec3<f32> {\n    let len = length(v);\n    return select(v / len, vec3<f32>(0.0), len == 0.0);\n}\n\nfn move_towards (matrix: mat4x4<f32>, towards: vec3<f32>, speed: f32) -> mat4x4<f32> {\n  let position = matrix[3].xyz;\n  var translation = safe_normalize(towards - position) * speed;\n  return translate(matrix, translation);\n}\n\nfn scale(matrix: mat4x4<f32>, scale: vec3<f32>) -> mat4x4<f32> {\n    return mat4x4<f32>(\n        vec4<f32>(matrix[0].x * scale.x, matrix[0].y * scale.y, matrix[0].z * scale.z, matrix[0].w),\n        vec4<f32>(matrix[1].x * scale.x, matrix[1].y * scale.y, matrix[1].z * scale.z, matrix[1].w),\n        vec4<f32>(matrix[2].x * scale.x, matrix[2].y * scale.y, matrix[2].z * scale.z, matrix[2].w),\n        matrix[3]\n    );\n}\n\nfn get_scale(matrix: mat4x4<f32>) -> vec3<f32> {\n    return vec3<f32>(length(matrix[0].xyz), length(matrix[1].xyz), length(matrix[2].xyz));\n}\n\nfn set_scale(matrix: mat4x4<f32>, scale: vec3<f32>) -> mat4x4<f32> {\n    return mat4x4<f32>(\n        vec4<f32>(scale.x, 0.0, 0.0, 0.0),\n        vec4<f32>(0.0, scale.y, 0.0, 0.0),\n        vec4<f32>(0.0, 0.0, scale.z, 0.0),\n        matrix[3]\n    );\n}\n\nfn rotate(matrix: mat4x4<f32>, angle: f32, _axis: vec3<f32>) -> mat4x4<f32> {\n    let c = cos(angle);\n    let s = sin(angle);\n    let t = 1.0 - c;\n\n    let axis = normalize(_axis);\n    let x = axis.x;\n    let y = axis.y;\n    let z = axis.z;\n\n    let rotationMatrix = mat4x4<f32>(\n        vec4<f32>(t * x * x + c,     t * x * y - s * z, t * x * z + s * y, 0.0),\n        vec4<f32>(t * x * y + s * z, t * y * y + c,     t * y * z - s * x, 0.0),\n        vec4<f32>(t * x * z - s * y, t * y * z + s * x, t * z * z + c,     0.0),\n        vec4<f32>(0.0,               0.0,               0.0,               1.0)\n    );\n\n    return matrix * rotationMatrix;\n}\n\nfn rotate_towards (matrix: mat4x4<f32>, towards: vec3<f32>) -> mat4x4<f32> {\n  let position = matrix[3].xyz;\n  let direction = normalize(towards - position);\n  let angle = acos(dot(vec3(0.0, 0.0, -1.0), direction));\n  \n\n  let axis = vec3(0.0, 0.0, -1.0);\n  return rotate(matrix, angle, axis);\n}\n\nfn get_position (matrix: mat4x4<f32>) -> vec3<f32> {\n  return matrix[3].xyz;\n}\n\nfn get_forward (matrix: mat4x4<f32>) -> vec3<f32> {\n  return (matrix * vec4<f32>(0,1,0,1)).xyz;\n}\n";class i extends e{constructor(e,i){super(e,i),this.meshes=[],this.bindGroupLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]}),this.avoidancePipeline=this.device.createComputePipeline({layout:this.device.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]}),compute:{module:this.device.createShaderModule({code:n+" \n "+t}),entryPoint:"avoidanceMain"}}),this.movementPipeline=this.device.createComputePipeline({layout:this.device.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]}),compute:{module:this.device.createShaderModule({code:n+" \n "+t}),entryPoint:"movementMain"}})}addMesh(e){this.meshes.push(e)}run(e,t){super.run(e,t);const n=e.beginComputePass();n.setPipeline(this.avoidancePipeline);for(let e of this.meshes)n.setBindGroup(0,e.getComputeBindGroup()),n.dispatchWorkgroups(Math.ceil(e.getInstanceCount()/64));n.setPipeline(this.movementPipeline);for(let e of this.meshes)n.setBindGroup(0,e.getComputeBindGroup()),n.dispatchWorkgroups(Math.ceil(e.getInstanceCount()/64));n.end()}}const r="struct TransformData {\r\n    view: mat4x4<f32>, // ALigns to 64 bytes\r\n    projection: mat4x4<f32>,\r\n    time: f32,\r\n    // padding: vec2<f32> // Aligns to 64 bytes \r\n};\r\n\r\nstruct ObjectData {\r\n    model: array<mat4x4<f32>>,\r\n}\r\n\r\n\r\n@binding(0) @group(0) var<uniform> transformUBO: TransformData;\r\n@binding(1) @group(0) var<storage, read> objects: ObjectData; // This is the 1\r\n@binding(2) @group(0) var characterTexture: texture_2d<f32>;\r\n@binding(3) @group(0) var characterSampler: sampler;\r\n\r\n@binding(4) @group(0) var<uniform> time: f32;\r\n\r\nstruct Fragment {\r\n    @builtin(position) Position : vec4<f32>,\r\n    @location(0) Color : vec4<f32>,\r\n    @location(1) ScreenPos: vec4<f32>,\r\n    @location(2) UV: vec2<f32>,\r\n    \r\n};\r\n\r\nfn randomColor(id: u32) -> vec4<f32> {\r\n    // generate a random color based on the object ID\r\n\r\n    var r = f32((id * 123) % 255) / 255.0;\r\n    var g = f32((id * 321) % 255) / 255.0;\r\n    // var b = f32((id * 213) % 255) / 255.0;\r\n\r\n    // if (id % 2 == 0) {\r\n    //     return vec4<f32>(72.0/255.0, 255.0/255.0, 146.0/255.0, 1.0);\r\n    // }\r\n    // else if (id % 3 == 0) {\r\n    //     return vec4<f32>(106.0/255.0, 201.0/255.0, 238.0/255.0, 1.0);\r\n    // }\r\n    // else {\r\n    //     return vec4<f32>(255.0/255.0, 56.0/255.0, 70.0/255.0, 1.0);\r\n    // }\r\n\r\n    // min 0.3\r\n    // max 1.0\r\n    // r = r * 0.7 + 0.3;\r\n    // r = 10.0/time;\r\n    return vec4<f32>(r, r, r, 1.0);\r\n}\r\n\r\n@vertex\r\nfn vs_main( @builtin(instance_index) ID: u32, @location(0) vertexPostion: vec3<f32>, @location(1) uv : vec2<f32>) -> Fragment {\r\n\r\n\r\n    var output : Fragment;\r\n\r\n    var idToF32 = f32(ID);\r\n\r\n    \r\n\r\n    var col = randomColor(ID * 23);\r\n\r\n    //min(col.x, 0.5, 1.0)\r\n    var minColX = min(col.x, 0.9);\r\n    output.Position = transformUBO.projection * transformUBO.view * objects.model[ID] * vec4<f32>(vertexPostion , 1.0);\r\n    // based on the y of the vertex, offset in the Z axis\r\n\r\n    // var col = vec4<f32>(0.0, 0.0, 1.0);\r\n\r\n    output.Color = col;\r\n    output.UV = vec2<f32>(uv.x, 1.0 - uv.y);\r\n\r\n    output.ScreenPos = output.Position;\r\n\r\n    return output;\r\n}\r\n\r\n@fragment\r\nfn fs_main(@location(0) Color: vec4<f32> ,@location(1) ScreenPos: vec4<f32>, @location(2) UV: vec2<f32>) -> @location(0) vec4<f32> {\r\n    // // Transform screenPosition to normalized device coordinates\r\n    // let uv = ScreenPos.xy * 0.5 + vec2<f32>(0.5, 0.5);\r\n    // let center = vec2<f32>(0.5, 0.5);\r\n    // let radius = 0.2;\r\n    // let dist = length(uv - center);\r\n\r\n    // // Render a red circle if within radius, otherwise show vertex color\r\n    // if (dist < radius) {\r\n    //     return vec4<f32>(1.0, 0.0, 0.0, 1.0);\r\n    // }\r\n    // return vec4<f32>(ScreenPos.xy, 1.0, 1.0); // return the input color as a fallback\r\n\r\n\r\n\r\n\r\n    var col = textureSample(characterTexture, characterSampler, UV.xy);\r\n\r\n    col = col * Color;\r\n\r\n    if (col.a < 0.1) {\r\n        discard;\r\n    }\r\n\r\n    return col;\r\n\r\n}\r\n";class a extends e{constructor(e,t){super(e,t),this.meshes=[],this.device=e,this.bindGroupLayout=this.device.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{}},{binding:1,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage",hasDynamicOffset:!1}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{}}]});const n=this.device.createPipelineLayout({bindGroupLayouts:[this.bindGroupLayout]});this.renderingPipeline=this.device.createRenderPipeline({vertex:{module:this.device.createShaderModule({code:r}),entryPoint:"vs_main",buffers:[{arrayStride:20,attributes:[{shaderLocation:0,format:"float32x3",offset:0},{shaderLocation:1,format:"float32x2",offset:12}]}]},fragment:{module:this.device.createShaderModule({code:r}),entryPoint:"fs_main",targets:[{format:t}]},primitive:{topology:"triangle-list"},layout:n})}addMesh(e){this.meshes.push(e)}run(e,t){const n=t.getCurrentTexture().createView(),i=e.beginRenderPass({colorAttachments:[{view:n,clearValue:{r:1,g:1,b:1,a:1},loadOp:"clear",storeOp:"store"}]});i.setPipeline(this.renderingPipeline);for(let e of this.meshes)i.setVertexBuffer(0,e.getVertexBuffer()),i.setBindGroup(0,e.getRenderBindGroup()),i.draw(e.getVertexCount(),e.getInstanceCount(),0,0);i.end()}}var o="undefined"!=typeof Float32Array?Float32Array:Array;function s(){var e=new o(16);return o!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}Math.random,Math.PI,Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var c;class d{constructor(e){this.cameraScale=200,this.time=0,this.renderer=e,this.device=e.device,this.cameraData={buffer:this.device.createBuffer({size:144,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),view:s(),projection:s(),transform:s(),leftRightBottomTop:[-8,8,-6,6]},this.cameraData.projection=s(),this.renderer.canvas.width=window.innerWidth,this.renderer.canvas.height=window.innerHeight,this.updateCamera(),window.addEventListener("resize",(()=>{this.updateCamera()})),window.addEventListener("wheel",(e=>{e.deltaY>0?this.cameraScale+=5:this.cameraScale-=5,console.log(this.cameraScale),this.updateCamera()}))}updateCamera(){var e=window.innerWidth/this.cameraScale,t=window.innerHeight/this.cameraScale;this.renderer.canvas.width=window.innerWidth,this.renderer.canvas.height=window.innerHeight,this.cameraData.leftRightBottomTop=[-e,e,-t,t],function(e,t,n,i,r,a,o){var s=1/(t-n),c=1/(i-r),d=1/(a-o);e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*c,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*d,e[11]=0,e[12]=(t+n)*s,e[13]=(r+i)*c,e[14]=(o+a)*d,e[15]=1}(this.cameraData.projection,-e,e,-t,t,0,20)}getCamera(){return this.cameraData}render(e,t){const n=performance.now()/1e3;this.time,this.time=n,this.device.queue.writeBuffer(this.cameraData.buffer,0,this.cameraData.view),this.device.queue.writeBuffer(this.cameraData.buffer,64,this.cameraData.projection),this.device.queue.writeBuffer(this.cameraData.buffer,128,new Float32Array([performance.now()/1e3]))}}function u(e,t,n,i){var r=new o(4);return r[0]=e,r[1]=t,r[2]=n,r[3]=i,r}c=new o(4),o!=Float32Array&&(c[0]=0,c[1]=0,c[2]=0,c[3]=0);class f{constructor(e,t,n){this.device=e,this.pass=t,this.scene=n}getVertexBuffer(){return this.vertexBuffer}getVertexCount(){return this.vertexCount}getVertices(){return this.vertices}getRenderBindGroup(){return this.bindGroup}}class l extends f{constructor(e,t,n){super(e,t,n),this.instanceCount=0}getInstanceCount(){return this.instanceCount}getObjectBuffer(){return this.objectBuffer}setObjectData(e){this.device.queue.writeBuffer(this.objectBuffer,0,e,0,e.length)}getComputeBindGroup(){return this.computeBindGroup}}var h=function(e,t,n,i){return new(n||(n=Promise))((function(r,a){function o(e){try{c(i.next(e))}catch(e){a(e)}}function s(e){try{c(i.throw(e))}catch(e){a(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,s)}c((i=i.apply(e,t||[])).next())}))};class v{constructor(){this.texture=null,this.view=null,this.sampler=null}loadTexture(e,t){return h(this,void 0,void 0,(function*(){var n;console.log("Loading texture");const i=yield fetch(t);console.log(i);const r=yield i.blob();console.log(r);const a=yield createImageBitmap(r);console.log(a),yield this.loadImageBitmap(e,a),this.view=null===(n=this.texture)||void 0===n?void 0:n.createView({format:"rgba8unorm",dimension:"2d",aspect:"all",baseArrayLayer:0,arrayLayerCount:1,mipLevelCount:1}),this.sampler=e.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1})}))}loadImageBitmap(e,t){return h(this,void 0,void 0,(function*(){const n={size:{width:t.width,height:t.height},format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT};this.texture=e.createTexture(n),e.queue.copyExternalImageToTexture({source:t},{texture:this.texture},n.size)}))}}class m extends l{constructor(e,t,n,i){super(e,t,n),this.instances=[],this.boids=[],this.time=0,this.computePass=i}init(){return e=this,t=void 0,i=function*(){const e=this.scene,t=new v;yield t.loadTexture(this.device,"guy-2.png"),console.log(t),this.vertices=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,-.5,.5,0,0,1,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),this.instanceCount=0,this.object_data=new Float32Array(32e4),this.boid_data=new Float32Array(24e4),this.vertexCount=6;const n=GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST,i={size:this.vertices.byteLength,usage:n,mappedAtCreation:!0};this.vertexBuffer=this.device.createBuffer(i),new Float32Array(this.vertexBuffer.getMappedRange()).set(this.vertices),this.vertexBuffer.unmap(),this.instanceCount=0,this.objectBuffer=this.device.createBuffer({size:128e4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.boidBuffer=this.device.createBuffer({size:96e4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.updateBoidBuffer(),this.timeUniform=this.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.deltaTimeUniform=this.device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.computeBindGroup=this.device.createBindGroup({layout:this.computePass.getBindGroupLayout(),entries:[{binding:0,resource:{buffer:this.objectBuffer}},{binding:1,resource:{buffer:this.boidBuffer}},{binding:2,resource:{buffer:this.timeUniform}},{binding:3,resource:{buffer:this.deltaTimeUniform}}]}),this.device.queue.writeBuffer(this.timeUniform,0,new Float32Array([0]).buffer),this.device.queue.writeBuffer(this.vertexBuffer,0,this.vertices.buffer,0),this.device.queue.writeBuffer(this.objectBuffer,0,this.object_data.buffer),this.bindGroup=this.device.createBindGroup({layout:this.pass.getBindGroupLayout(),entries:[{binding:0,resource:{buffer:e.getCamera().buffer}},{binding:1,resource:{buffer:this.getObjectBuffer()}},{binding:2,resource:t.view},{binding:3,resource:t.sampler}]})},new((n=void 0)||(n=Promise))((function(r,a){function o(e){try{c(i.next(e))}catch(e){a(e)}}function s(e){try{c(i.throw(e))}catch(e){a(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,s)}c((i=i.apply(e,t||[])).next())}));var e,t,n,i}setBoidTarget(e,t){if(t>=this.boids.length)return void console.warn("Index out of bounds");const n=this.boids[t];!function(e,t,n,i){e[0]=t,e[1]=n,e[2]=i,e[3]=1}(n.target,e[0],e[1],e[2]),n.hasTarget=!0,this.setBoidData(t,n)}setBoidData(e,t){const n=12;this.boid_data?(this.boid_data[e*n]=t.target[0],this.boid_data[e*n+1]=t.target[1],this.boid_data[e*n+2]=t.target[2],this.boid_data[e*n+3]=t.target[3],this.boid_data[e*n+4]=t.avoidance[0],this.boid_data[e*n+5]=t.avoidance[1],this.boid_data[e*n+6]=t.avoidance[2],this.boid_data[e*n+7]=t.avoidance[3],this.boid_data[e*n+8]=t.hasTarget?1:0,this.boid_data[e*n+9]=t.speed):console.warn("Boid data not initialized")}addGuy(e){if(!this.object_data||!this.boid_data)return void console.warn("Instance data not initialized");if(!this.object_data||!this.boid_data)return void console.warn("Instance data not initialized");const t=s();!function(e,t,n){var i,r,a,o,s,c,d,u,f,l,h,v,m=n[0],g=n[1],p=n[2];t===e?(e[12]=t[0]*m+t[4]*g+t[8]*p+t[12],e[13]=t[1]*m+t[5]*g+t[9]*p+t[13],e[14]=t[2]*m+t[6]*g+t[10]*p+t[14],e[15]=t[3]*m+t[7]*g+t[11]*p+t[15]):(i=t[0],r=t[1],a=t[2],o=t[3],s=t[4],c=t[5],d=t[6],u=t[7],f=t[8],l=t[9],h=t[10],v=t[11],e[0]=i,e[1]=r,e[2]=a,e[3]=o,e[4]=s,e[5]=c,e[6]=d,e[7]=u,e[8]=f,e[9]=l,e[10]=h,e[11]=v,e[12]=i*m+s*g+f*p+t[12],e[13]=r*m+c*g+l*p+t[13],e[14]=a*m+d*g+h*p+t[14],e[15]=o*m+u*g+v*p+t[15])}(t,t,[e[0],e[1],-10]),function(e,t,n){var i=n[0],r=n[1],a=n[2];e[0]=t[0]*i,e[1]=t[1]*i,e[2]=t[2]*i,e[3]=t[3]*i,e[4]=t[4]*r,e[5]=t[5]*r,e[6]=t[6]*r,e[7]=t[7]*r,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]}(t,t,[.3,.3,.3]),this.instances.push(t);const n=this.instanceCount;for(let e=0;e<16;e++)this.object_data[16*n+e]=t[e];const i={target:u(0,0,0,1),hasTarget:!1,avoidance:u(0,0,0,0),speed:Math.random()+.3};this.boids.push(i),this.setBoidData(n,i),this.instanceCount++;const r=16*n*4,a=12*n*4;this.device.queue.writeBuffer(this.objectBuffer,r,this.object_data.buffer,r,64),this.device.queue.writeBuffer(this.boidBuffer,a,this.boid_data.buffer,a,48)}updateBuffers(){if(!(this.boidBuffer&&this.boid_data&&this.timeUniform&&this.deltaTimeUniform))return void console.warn("Boid buffer not initialized");const e=performance.now()/1e3,t=e-this.time;this.time=e,this.device.queue.writeBuffer(this.timeUniform,0,new Float32Array([e]).buffer),this.device.queue.writeBuffer(this.deltaTimeUniform,0,new Float32Array([t]).buffer)}updateBoidBuffer(){this.boidBuffer&&this.boid_data&&this.timeUniform&&this.deltaTimeUniform?this.device.queue.writeBuffer(this.boidBuffer,0,this.boid_data.buffer,0,4*this.boid_data.length):console.warn("Boid buffer not initialized")}}function g(){var e=new o(3);return o!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function p(e,t,n){var i=new o(3);return i[0]=e,i[1]=t,i[2]=n,i}function x(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}g();class b extends d{constructor(e){super(e),this.mouseToWorld=(e,t)=>{var n=this.renderer.canvas.getBoundingClientRect(),i=e.clientX-n.left,r=e.clientY-n.top,a=this.cameraData.leftRightBottomTop,o=i/this.renderer.canvas.width,s=1-r/this.renderer.canvas.height;return p(a[0]+(a[1]-a[0])*o,a[2]+(a[3]-a[2])*s,t)},this.particleRenderPass=new a(this.device,e.format),this.computePass=new i(this.device,e.format),this.particleMesh=new m(this.device,this.particleRenderPass,this,this.computePass),this.setupParticles(),setTimeout((()=>{let e=!1,t=0,n=0;window.addEventListener("mousedown",(t=>{e=!0,i()})),window.addEventListener("mouseup",(()=>{e=!1,this.particleMesh.updateBuffers(),this.particleMesh.updateBoidBuffer()})),window.addEventListener("mousemove",(e=>{t=e.clientX,n=e.clientY}));const i=()=>{const i=()=>{if(e){this.mousePosWorld=this.mouseToWorld({clientX:t,clientY:n},-10);for(let e=0;e<3;e++){console.log("Adding guy");const e=p(.2*Math.random()-.1,.2*Math.random()-.1,0);this.particleMesh.addGuy(x(g(),this.mousePosWorld,e))}requestAnimationFrame(i)}};i()}}),50)}setupParticles(){return e=this,t=void 0,i=function*(){yield this.particleMesh.init(),this.computePass.addMesh(this.particleMesh),this.particleRenderPass.addMesh(this.particleMesh)},new((n=void 0)||(n=Promise))((function(r,a){function o(e){try{c(i.next(e))}catch(e){a(e)}}function s(e){try{c(i.throw(e))}catch(e){a(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,s)}c((i=i.apply(e,t||[])).next())}));var e,t,n,i}render(e,t){if(super.render(e,t),this.mousePosWorld){for(let e=0;e<this.particleMesh.boids.length;e++)100*Math.random()>20||p(5*Math.random()-2.5,5*Math.random()-2.5,0);this.particleMesh.updateBuffers(),this.particleMesh.updateBoidBuffer()}this.computePass.run(e,t),this.particleRenderPass.run(e,t)}}class y extends b{setupParticles(){const e=Object.create(null,{setupParticles:{get:()=>super.setupParticles}});return t=this,n=void 0,r=function*(){e.setupParticles.call(this)},new((i=void 0)||(i=Promise))((function(e,a){function o(e){try{c(r.next(e))}catch(e){a(e)}}function s(e){try{c(r.throw(e))}catch(e){a(e)}}function c(t){var n;t.done?e(t.value):(n=t.value,n instanceof i?n:new i((function(e){e(n)}))).then(o,s)}c((r=r.apply(t,n||[])).next())}));var t,n,i,r}}var w=function(e,t,n,i){return new(n||(n=Promise))((function(r,a){function o(e){try{c(i.next(e))}catch(e){a(e)}}function s(e){try{c(i.throw(e))}catch(e){a(e)}}function c(e){var t;e.done?r(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,s)}c((i=i.apply(e,t||[])).next())}))};const P=document.getElementById("gfx-main"),B=new class{constructor(e){this.t=0,this.render=()=>{this.t+=.01;const e=this.device.createCommandEncoder();this.scene.render(e,this.context),this.device.queue.submit([e.finish()]),requestAnimationFrame(this.render)},this.canvas=e,this.t=0}Initialize(){return w(this,void 0,void 0,(function*(){yield this.setupDevice(),this.scene=new y(this),this.render()}))}setupDevice(){return w(this,void 0,void 0,(function*(){var e,t;this.adapter=yield null===(e=navigator.gpu)||void 0===e?void 0:e.requestAdapter(),this.device=yield null===(t=this.adapter)||void 0===t?void 0:t.requestDevice(),this.context=this.canvas.getContext("webgpu"),this.format="bgra8unorm",this.context.configure({device:this.device,format:this.format,alphaMode:"opaque"}),this.device.addEventListener("uncapturederror",(e=>console.error(e)))}))}}(P);B.Initialize()})();